import { useRef, useState } from "react";
import {
    BufferGeometry,
    Group,
    MathUtils,
    NormalBufferAttributes,
    Object3D,
} from "three";
import { Euler, useFrame, Vector3 } from "@react-three/fiber";
import { ThreeEvent } from "@react-three/fiber/dist/declarations/src/core/events";
import { Float, useGLTF } from "@react-three/drei";
import {
    itemsPolarTransform,
    MeshTransform,
} from "../../../utils/MeshManipulationUtils.ts";

function HeroDevices() {
    const itemsCount = 7;
    const itemsPositionRadius = 3;
    const rotationSpeed = 0.15;
    const interpolationSpeed = 0.025;
    const minSpeedMultiplier = 0.15;

    // const [hovers, setHovers] = useState(() =>
    //     new Array<boolean>(itemsCount).fill(false),
    // );

    const transforms: MeshTransform[] = new Array<MeshTransform>(itemsCount)
        .fill({})
        .map((_m, i) => {
            const theta = (i * Math.PI * 2) / itemsCount;
            return itemsPolarTransform(theta, itemsPositionRadius);
        });

    // function updateHovers(idx: number, newValue: boolean) {
    //     setHovers(oldHovers => {
    //         const newHovers = [...oldHovers];
    //         newHovers[idx] = newValue;
    //         return newHovers;
    //     });
    // }

    const devicesRef = useRef<Group>(null!);
    const smooth = useRef<number>(1);
    const targetVelocity = useRef<number>(1);

    useFrame((_state, delta) => {
        smooth.current = MathUtils.lerp(
            smooth.current,
            targetVelocity.current,
            interpolationSpeed,
        );

        devicesRef.current.rotation.y += delta * rotationSpeed * smooth.current;
    });

    return (
        <>
            <group position={[0, -3, 0]} ref={devicesRef}>
                {transforms.map((transform, idx) => (
                    <Float
                        floatIntensity={0.25}
                        speed={10}
                        position={[0, 2, 0]}
                        rotationIntensity={0}
                        key={idx}>
                        <Model
                            index={idx}
                            position={transform.position ?? [0, 0, 0]}
                            rotation={transform.rotation ?? [0, 0, 0]}
                            onHover={e => {
                                e.stopPropagation();
                                // updateHovers(idx, true);
                                targetVelocity.current = minSpeedMultiplier;
                            }}
                            onLeave={e => {
                                e.stopPropagation();
                                // updateHovers(idx, false);
                                targetVelocity.current = 1;
                            }}
                        />
                    </Float>
                ))}
            </group>
        </>
    );
}

type ModelProps = {
    index: number;
    position: Vector3;
    rotation: Euler;
    onHover?: (event: ThreeEvent<PointerEvent>) => void;
    onLeave?: (event: ThreeEvent<PointerEvent>) => void;
};

type IGeometry = Object3D & {
    geometry: BufferGeometry<NormalBufferAttributes>;
};

function Model({ index, position, rotation, onHover, onLeave }: ModelProps) {
    console.log(index);

    const [isHover, setIsHover] = useState(false);

    const group = useRef<Group>(null!);
    // Load model
    const { nodes, materials } = useGLTF("/mac.glb");

    // The jsx graph was auto-generated by: https://github.com/pmndrs/gltfjsx
    return (
        <group
            ref={group}
            onPointerEnter={e => {
                onHover?.(e);
                setIsHover(true);
            }}
            onPointerLeave={e => {
                onLeave?.(e);
                setIsHover(false);
            }}
            dispose={null}
            scale={isHover ? [0.25, 0.25, 0.25] : [0.2, 0.2, 0.2]}
            position={position}
            rotation={rotation}>
            <group rotation-x={-0.425} position={[0, -0.04, 0.41]}>
                <group
                    position={[0, 2.96, -0.13]}
                    rotation={[Math.PI / 2, 0, 0]}>
                    <mesh
                        material={materials.aluminium}
                        geometry={(nodes["Cube008"] as IGeometry)["geometry"]}
                    />
                    <mesh
                        material={materials["matte.001"]}
                        geometry={(nodes["Cube008_1"] as IGeometry)["geometry"]}
                    />
                    <mesh
                        geometry={
                            (nodes["Cube008_2"] as IGeometry)["geometry"]
                        }>
                        <meshStandardMaterial color='#2e3335' />
                    </mesh>
                </group>
            </group>
            <mesh
                material={materials.keys}
                geometry={(nodes.keyboard as IGeometry)["geometry"]}
                position={[1.79, 0, 3.45]}
            />
            <group position={[0, -0.1, 3.39]}>
                <mesh
                    material={materials.aluminium}
                    geometry={(nodes["Cube002"] as IGeometry)["geometry"]}
                />
                <mesh
                    material={materials.trackpad}
                    geometry={(nodes["Cube002_1"] as IGeometry)["geometry"]}
                />
            </group>
            <mesh
                material={materials.touchbar}
                geometry={(nodes.touchbar as IGeometry)["geometry"]}
                position={[0, -0.03, 1.2]}
            />
        </group>
    );
}

export default HeroDevices;
